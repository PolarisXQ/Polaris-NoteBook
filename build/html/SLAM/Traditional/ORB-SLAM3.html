<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>ORB_SLAM</title>
    
          <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/theme.css " type="text/css" />
          <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script src="../../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../_static/theme-vendors.js"></script> -->
      <script src="../../_static/theme.js" defer></script>
    
      <link rel="shortcut icon" href="../../_static/madcat_mini.png"/>
  <link rel="index" title="索引" href="../../genindex.html" />
  <link rel="search" title="搜索" href="../../search.html" />
  <link rel="next" title="阅读推荐" href="RecommendReading.html" />
  <link rel="prev" title="An Simple Overview" href="../overview.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../index.html" class="home-link">
    
      <img class="logo" src="../../_static/madcat_mini.png" alt="logo"/>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



  
    <div class="nav-item">
      <a href="https://github.com/PolarisXQ"
        class="nav-link external">
          Github <outboundlink></outboundlink>
      </a>
    </div>
  

    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



  
    <div class="nav-item">
      <a href="https://github.com/PolarisXQ"
        class="nav-link external">
          Github <outboundlink></outboundlink>
      </a>
    </div>
  

            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../index.html#welcome-to-polaris-notebook">welcome to polaris' notebook!</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../Sys.html" class="reference internal ">Sys</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../../SLAM.html" class="reference internal ">SLAM</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../../Docker.html" class="reference internal ">Docker</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
    
      <li><a href="../../SLAM.html">SLAM</a> &raquo;</li>
    
    <li>ORB_SLAM</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="../overview.html"
       title="上一章">← An Simple Overview</a>
  </li>
  <li class="next">
    <a href="RecommendReading.html"
       title="下一章">阅读推荐 →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="orb-slam">
<h1>ORB_SLAM<a class="headerlink" href="#orb-slam" title="此标题的永久链接">¶</a></h1>
<section id="orb-oriented-fast-rotated-brief-feature-extraction">
<h2>ORB（Oriented FAST + Rotated BRIEF） Feature Extraction<a class="headerlink" href="#orb-oriented-fast-rotated-brief-feature-extraction" title="此标题的永久链接">¶</a></h2>
<p><strong>步骤:</strong>
<img alt="../../_images/step_orb_ext.png" src="../../_images/step_orb_ext.png" /></p>
<ol class="simple">
<li><p>输入图像，并对输入图像进行预处理，将其转换成灰度图像；</p></li>
<li><p>初始化参数，包括特征点数量nfeatures，尺度scaleFactor，金字塔层数nlevel，初始阈值iniThFAST，最小阈值minThFAST等参数；</p></li>
<li><p>计算金字塔图像，源码中使用8层金字塔，尺度因子为1.2，则通过对原图像进行不同层次的resize，可以获得8层金字塔的图像；</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>FAST特征点和ORB描述子本身不具有尺度信息，ORBextractor通过构建图像金字塔来得到特征点尺度信息.将输入图片逐级缩放得到图像金字塔,金字塔层级越高,图片分辨率越低,ORB特征点越大.
</pre></div>
</div>
<ol class="simple">
<li><p>计算特征点：</p>
<ul class="simple">
<li><p>将图像分割成网格，每个网格大小为W<em>W=30</em>30像素；</p></li>
<li><p>遍历每个网格；</p></li>
<li><p>对每个网格提取FAST关键点，先用初始阈值iniThFAST提取，若提取不到关键点，则改用最小阈值minThFAST提取。（注意，初始阈值一般比最小阈值大）</p></li>
</ul>
</li>
<li><p>对所有提取到的关键点利用八叉树的形式进行划分：</p>
<ul class="simple">
<li><p>为了使得分布更加均匀</p></li>
<li><p>按照像素宽和像素高的比值作为初始的节点数量，并将关键点坐标落在对应节点内的关键点分配入节点中；</p></li>
<li><p>根据每个节点中存在的特征点数量作为判断依据，如果当前节点只有1个关键点，则停止分割。否则继续等分成4份；</p></li>
<li><p>按照上述方法不断划分下去，如图3所示，可见出现一个八叉树的结构，终止条件是节点的数目Lnode大于等于要求的特征点数量nfeatures；</p></li>
<li><p>对满足条件的节点进行遍历，在每个节点中保存响应值最大的关键点，保证特征点的高性能；</p></li>
</ul>
</li>
<li><p>对上述所保存的所有节点中的特征点计算主方向，利用灰度质心的方法计算主方向，上一讲中我们已经讲解过方法，这讲就不再赘述了；</p></li>
<li><p>对图像中每个关键点计算其描述子，值得注意的是，为了将主方向融入BRIEF中，在计算描述子时，ORB将pattern进行旋转，使得其具备旋转不变性；(随便理解一下把)</p></li>
</ol>
</section>
<section id="feature-matching">
<h2>Feature Matching<a class="headerlink" href="#feature-matching" title="此标题的永久链接">¶</a></h2>
<p><strong>步骤：</strong></p>
<ol class="simple">
<li><p>对新来的帧进行特征提取</p></li>
<li><p>将特征依据字典树转换成BOW向量</p></li>
<li><p>在匹配时我们查找两帧BOW向量中相同ID的词汇，特征匹配只在有相同ID的词汇中进行。显然，这个过程限定了匹配范围，可以提高匹配的速度。当然，匹配的精度跟词汇树的大小和深度有关系。</p></li>
</ol>
<section id="id1">
<h3>词袋模型<a class="headerlink" href="#id1" title="此标题的永久链接">¶</a></h3>
<ul class="simple">
<li><p>字典是预先准备的。</p></li>
<li><p>优点在于：</p>
<ul>
<li><p>把图片抽象成了几个单词的集合，在数学上用向量就可以简单表示，称为BOW向量。</p></li>
<li><p>准备字典时，把单词通过多层聚类的方法进行分类，通过树进行索引，这个检索过程能达到对数级别的查找效率。</p></li>
</ul>
</li>
</ul>
</section>
<section id="id2">
<h3>确定最优匹配？？？？<a class="headerlink" href="#id2" title="此标题的永久链接">¶</a></h3>
<p>ORBSLAM2中将360°分成30个bin，每个bin的范围是12°。对于图像1和图像2任意两个对应匹配特征，我们计算其二者主方向的夹角。根据夹角的大小确定在哪个角度范围里，并将特征索引存入对应bin中。</p>
<p>我们统计每个bin中保存的索引数量，取数量最多的前三个bin作为最终的匹配对结果。其他的匹配对全部予以删除。至此，我们的最优匹配就全部确定了。</p>
<p>不过，值得注意的是，我们实际上匹配的点只是一部分，另一部分没有匹配到的，在后面会通过共试图关键帧以及局部地图重投影进行进一步匹配，我们会在后续的内容中讲解。</p>
</section>
</section>
<section id="motion-estimation">
<h2>Motion Estimation<a class="headerlink" href="#motion-estimation" title="此标题的永久链接">¶</a></h2>
<section id="id3">
<h3>在跟踪过程主要分为三种类型，来确定优化的初始值：<a class="headerlink" href="#id3" title="此标题的永久链接">¶</a></h3>
<p><img alt="../../_images/motion_est.png" src="../../_images/motion_est.png" /></p>
<ol class="simple">
<li><p>无运动模型的跟踪，即基于参考帧的跟踪；</p></li>
<li><p>基于匀速运动模型的跟踪；
　ORBSLAM2中每次跟踪成功后，都会将两帧间的相对运动记录下来作为运动模型。在估计下一帧运动时，将前一帧的姿态，乘上这个运动模型，就得到了<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>的姿态初值。</p></li>
<li><p>重定位(需要用到回环检测)；</p></li>
</ol>
</section>
<section id="pnp">
<h3>优化方法PNP<a class="headerlink" href="#pnp" title="此标题的永久链接">¶</a></h3>
<p>PNP是一种将匹配点从三维空间投影到像平面并与观测数据计算误差来估计相机运动的方法，我们也管这种方法叫重投影误差。
使用重投影（与观测的）误差，通过优化的算法解的使得误差最小的运动矩阵,作为运动估计。</p>
<p>基于解析的PNP方法:</p>
<ol class="simple">
<li><p>只采用少量的匹配对即可估计相对运动;</p></li>
<li><p>SLAM问题当中，通常约束条件较多，因此基于解析的方法通常不能更好地利用约束条件;</p></li>
<li><p>若将错误匹配对纳入解析方程中，会错误估计相机运动</p></li>
<li><p>尽管可以通过随机选取多组匹配对进行估算多个相机运动并根据一定条件进行筛选出最合适的相机运动，但是笔者更倾向于用PNP解析解估算出一个初值;</p></li>
<li><p>值得一提的是，ORBSLAM2并不用PNP求初值，而是直接用参考帧的运动作为<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>的运动初值进行优化;</p></li>
</ol>
<p><span style="color:green;">人生苦短，证明就略过把😎</span></p>
<p>反正最后得到了误差对运动矩阵的导数式，然后就可以用g2o或者ceres来求解最小误差（最小二乘法）的运动矩阵了。</p>
<section id="id4">
<h4>关于优化算法<a class="headerlink" href="#id4" title="此标题的永久链接">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    1. 梯度下降法：

    · 只考虑了该点是否在下降

    · 实际上，由于梯度下降法过于贪心，通常会导致锯齿状下降，导致收敛速度缓慢；而且会陷入局部最优或者鞍点问题

    2. 牛顿法：

    · 不仅参考了一点的导数，还参考了导数的导数；考虑了下降后这个方向是不是依然在下降，可以优化梯度下降法中最终可能找到鞍点等错误的点的情况。

    · 而牛顿法尽管使用了二阶近似，提高了下降速度，但对于SLAM问题而言，求解海塞阵的计算量太大，非常不适用；

    ！！！！以下还没读懂！！！！！
    -----------------------------------

    3. 高斯牛顿法：

    　　基于牛顿法改进的高斯牛顿法，通过二次近似二阶泰勒展开，利用雅克比的二次方来近似海塞阵，在计算量和下降速度上可以较好满足SLAM的需求，但存在的隐患是增量的范围超出泰勒展开时限定的微小邻域，导致近似失败；

    4. 列文伯格-马夸尔特法：

    　　列文伯格-马夸尔特法是基于高斯牛顿法进一步改进的，通过限定搜索区域，防止出现近似失败的情况，LM方法也是SLAM中最常用的优化方法。

    -----------------------------------
</pre></div>
</div>
</section>
</section>
</section>
<section id="span-style-color-green-keyframe-span">
<h2><span style="color:green;">KeyFrame</span><a class="headerlink" href="#span-style-color-green-keyframe-span" title="此标题的永久链接">¶</a></h2>
<p>关键帧的目的在于，适当地降低信息冗余度，减少计算机资源的损耗，保证系统的平稳运行</p>
<section id="span-style-color-green-kf-s-selection-span">
<h3><span style="color:green;">KF’s Selection</span><a class="headerlink" href="#span-style-color-green-kf-s-selection-span" title="此标题的永久链接">¶</a></h3>
<ol>
<li><p>若当前处于定位模式，不插入关键帧；</p>
<p>原因：定位模式是只定位不建图</p>
</li>
<li><p>若局部地图处于全局闭环情况下，不插入关键帧；</p>
<p>原因：局部地图被占用，插入关键帧会影响全局闭环的优化。</p>
</li>
<li><p>若距离上一次重定位较近，不插入关键帧；</p>
<p>原因：重定位时，<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>通过与局部关键帧匹配并进行运动估计，能够很好地恢复其运动姿态。笔者认为，因为重定位时<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>与重定位<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>的信息冗余度较低，所以在重定位成功后，<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>会作为关键帧插入地图中。而新来的一帧，由于重定位时刚刚插入关键帧，所以不需要频繁插入。</p>
</li>
</ol>
<p>排除了上面三种情况，接下来就需要对关键帧进一步检测，才能确定是否真的需要插入关键帧。进一步检查包含一个必不可少的条件和另外三选一的条件。</p>
<ol>
<li><p>内点数必须超过设定的最小阈值，并且重叠度不能太大；</p>
<p>原因：保证关键帧跟踪的质量，同时，避免引入过多的信息冗余。</p>
</li>
</ol>
<p>三选一的条件：</p>
<p>2.1 距离上次插入关键帧已经过去MAX帧，MAX是ORBSLAM2预设的最大值；</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>原因：防止过去太多帧，跟踪丢失。
</pre></div>
</div>
<p>2.2 距离上次插入关键帧至少过去MIN帧，且局部建图线程处于空闲状态，MIN是ORBSLAM2预设的最小值；</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>原因：防止图像重叠度太高，并且局部建图线程有空闲处理新的关键帧。
</pre></div>
</div>
<p>2.3 局部建图线程中关键帧队列的关键帧数量不超过3个；</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>原因：主要也是考虑局部建图线程的处理能力，以及信息的冗余度问题吧。
</pre></div>
</div>
<p>插入关键帧的条件即是必须满足条件1以及满足2.1-2.3中任意一个条件。</p>
</section>
<section id="span-style-color-green-kf-s-insertation-span">
<h3><span style="color:green;">KF’s Insertation</span><a class="headerlink" href="#span-style-color-green-kf-s-insertation-span" title="此标题的永久链接">¶</a></h3>
</section>
</section>
<section id="id5">
<h2>地图的更新策略<a class="headerlink" href="#id5" title="此标题的永久链接">¶</a></h2>
</section>
<section id="kp-s-triangular">
<h2>KP’s Triangular<a class="headerlink" href="#kp-s-triangular" title="此标题的永久链接">¶</a></h2>
<p>三角化是用来估计相机和地图上的三维点之间的关系。具体来说，当ORB-SLAM使用两个或更多个视角拍摄同一场景时，它会使用三角化算法将这些视角中观察到的特征点转换为三维点。这些三维点可以用于构建地图和定位相机。</p>
<p>当一个特征点在至少两个视角下都有匹配时，ORB-SLAM会使用三角化技术计算该特征点的3D位置。因此，只有那些至少在两个视角下都有匹配的特征点才会被用于三角化。</p>
</section>
<section id="loop-closing">
<h2>Loop Closing<a class="headerlink" href="#loop-closing" title="此标题的永久链接">¶</a></h2>
<p>回环检测模块包含两个部分的内容：其一是位置识别，即外观验证，通过图像间的相似度信息进行判断；其二是几何验证，通过回环<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>与当前关键帧的几何关系来做进一步验证。</p>
<section id="loop-detection">
<h3>Loop Detection<a class="headerlink" href="#loop-detection" title="此标题的永久链接">¶</a></h3>
<ol class="simple">
<li><p>利用一范数来度量<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>与<span style="color:RGB(46,160,67); font-weight: 600;">共视图关键帧</span>之间的相似度分数，假设共视图中一个关键帧的BOW向量为$w$，<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>的BOW向量为$v$，则相似度分数的度量方式为：
$s(w−v)=2∑_{i=1}^N|w_i|+|v_i|−|w_i−v_i|$
　　将所有相似分数进行排序，取最小的匹配分数 $S_{min}$ 作为参考值，用于查找回环<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>。</p></li>
<li><p>确定最小匹配分数后，排除<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span><span style="color:RGB(46,160,67); font-weight: 600;">共视图的所有关键帧</span>，我们回环的意义是确定当前相机看到的场景，在很久之前是不是见过。近期看到的<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>的<span style="color:RGB(46,160,67); font-weight: 600;">共视图关键帧</span>，这对校正整个场景的误差作用不大。</p></li>
<li><p>对<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>的BOW向量中的词汇逐个逆向索引在地图中找到相关联的关键帧，参考下图。并统计各个关键帧中与<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>相似的词汇数量。排序确定最大的相似词汇数量 $M$，并筛选相似词汇数量大于$0.8×M$的关键帧作为<span style="color:RGB(195,83,195); font-weight: 600;">候选帧 $KF^1_{candidate}$</span>；</p></li>
<li><p>将<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>与步骤3的<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>进行BOW向量计算匹配分数，取匹配分数高于步骤1计算的最小匹配分数 $Smin$ 的<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>作为新的<span style="color:RGB(195,83,195); font-weight: 600;">候选帧 $KF^2_{candidate}$</span>；</p></li>
<li><p>统计<span style="color:RGB(195,83,195); font-weight: 600;">候选帧集中 $KF^2_{candidate}$</span>
每个<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>的<span style="color:RGB(46,160,67); font-weight: 600;">共视图关键帧</span>与<span style="color:RGB(0,120,212); font-weight: 600;">当前帧</span>的BOW匹配分数总和 $S_total$，并取分数总和大于 $0.75×S_total$ 的<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>组成新的<span style="color:RGB(195,83,195); font-weight: 600;">候选帧$KF^3_{candidate}$</span>。
笔者理解这也是为了确保在一个范围里都能检测到回环，增强回环的可靠性。</p></li>
<li><p>在上述<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span> $KF^3_{candidate}$ 的基础上，我们检测连续三帧都识别到同一个回环，那么就可以进一步缩小<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>集，形成最终的<span style="color:RGB(195,83,195); font-weight: 600;">候选帧集 $KF_{final-candudate}$</span>，这在ORBSLAM2中叫一致性验证。</p></li>
</ol>
<p>至此，我们的外观验证已经完成了。从步骤1开始到步骤6，ORBSLAM2都是在不断提高筛选条件进而缩小<span style="color:RGB(195,83,195); font-weight: 600;">候选帧集</span>。可以想见，这是在利用词袋模型检索和匹配效率极高的优势，快速完成粗检索，精细化的部分再交由几何验证去进一步确定最终的<span style="color:RGB(195,83,195); font-weight: 600;">候选帧</span>。</p>
</section>
<section id="geometry-validation">
<h3>Geometry Validation<a class="headerlink" href="#geometry-validation" title="此标题的永久链接">¶</a></h3>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="../overview.html"
       title="上一章">← An Simple Overview</a>
  </li>
  <li class="next">
    <a href="RecommendReading.html"
       title="下一章">阅读推荐 →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, PolarisXQ.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>